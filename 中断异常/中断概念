通常同一CPU的任务片切换以及底层事件的触发都是靠中断来触发。中断又分为“硬件中断”和“软件中断”。中断一般与硬件电路产生的电信号相互对应。另一方面，中断又分为 同步中断“synchronous”和异步中断“asyncchronous”。
同步中断一般叫做“异常”，异步中断叫做“中断”。
从字面上理解，同步中断是伴随着CPU发出的，只有当一个任务或者一条命令的终止后，CPU发出。
异步中断则是由相关设备伴随CPU时钟信号随机产生的。
按照两者的特性，把同步中断叫做“异常”，把异步中断叫做“中断”。
引起“异常”最直观的原因就是程序错误，代码有问题。除此之外，有些异常对于系统是必须存在的。例如，Linux分配内存页采用异常机制，当访问请求某内存页时，如果该页不存在，MMU则会抛出一个缺页异常，然后触发相关的机制分配内存页。
在内核中，中断是随时可以出现的，不论内核正在处理什么进程任务甚至是上一个中断，内核会根据中断的类型来决定是否马上处理中断引起的相应程序，但前提是一定会停下来处理中断，做出判断，只为了尽可能的让中断尽可能迅速处理完。举个例子，当内核正在处理一个任务进程时，一个数据包触发了硬件中断，内核会停下手头的任务，然后标记数据包到达，然后恢复刚才的处理状态，对于该数据包的后续操作将留在后续时间。如果内核正在处理一个中断，此时又来一个新的中断，那么内核需要处理新的中断，并且处理完成后还要恢复刚才的中断处理。当然，在处理某些任务时 是会有临界区，处于该区域时会禁止中断。
中断分为三个等级：
	1.紧急的
	2.非紧急
	3.非紧急可延迟
单核------------------------------------------------------------------------------------------------
每个能够发出IRQ（中断请求）的硬件设备都有一条或多条名为（IRQ）的线，这些线与“可编程逻辑控制器(PIC)”的硬件电路输入相连,该线是从0开始编号，该硬件电路会做一下动作：
	1.监听IRQ线，检查信号。如果有两条或以上线路同时产生信号，优先选择引脚号小的。
	2.如果一个引发信号出现在IRQ线上。
	      a.把接受到的引发信号转换为对应向量(每个中断和异常用0-255之间整数来表示，8位无符号整数叫			做向量)
	      b.把这个向量存放在中断控制器的一个I/O端口，允许CPU通过总线读取该向量
	      c.把引发信号发送到处理器INTR引脚，从而产生一个中断
	      d.等待，直到CPU把该中断信号写进PIC的一个I/O端口来确认；当这种情况发生，请INTR线。
	3.返回第一步
多核-------------------------------------------------------------------------------------------------
多核情况中断需要能够能够传给每个CPU，所以引入了“I/O高级可编程控制器”(I/O APIC)代替老PIC,新的 I/O APIC利用总线把消息发送给多CPU自己的APIC单元。中断请求在总线上分发给每个CPU的方式有两种：
	1.静态分发：IRQ按照重定向表中的信息(所有本地APIC信息)，中断立即发送给一个，一组或全部CPU
	2.动态分发：那个CPU正在处理优先级最低的进程，IRQ信号就给谁。

软中断：一个中断的几个中断服务例程是串行执行的，如果正在处理某种中断时，这种类型的中断就不会再次产生，         而可延迟中断，可以利用CPU能够延迟处理的机制产生多次中断，利用这种方法，来满足那些需要中断在几毫秒内得到处理的应用
在内核层次，软中断表示那些可以能够可延迟函数的所有种类。
软中断是在编译时就定义的，而tasklet基于软中断之上实现，可以在运行时进行初始化和分配，换句话说tasklet可以产生很多种，相同类型的只能在一个CPU上串行执行，不同类型可以并发在多个CPU上执行。因此将tasklet运用到了操作系统中，进行了多个类型的定义。
Linux上有多个软中断：
	HI_SOFTRQ:		处理高优先级的tasklet
	TIMER_SOFTIRQ:		和时钟中断有关的tasklet
	NET_TX_SOFTIRQ：	把数据包传送到网卡
	NET_RX_SOFTIRQ:		从网卡接受数据包
	SCSI_SOFTIRQ:		SCSI命令后台中断处理
	TASKLET_SOFTIRQ:	处理常规tasklet
在有的内核中，每个CPU都有自己的ksoftirqd/n内核线程（n为CPU逻辑号）。该内核线程都运行ksoftirqd()函数
