Unix系统提供了一层叫做“虚拟内存”的逻辑内存层，处于应用程序的内存请求和硬件内存管理单元（Memory management Unit，MMU）之间。有了虚拟内存可以实现：
	1.若干个进程并发执行
	2.应用程序所需内存大于物理内存也能运行（只有到真正需要时，才会真正分配内存页）
	3.因为虚拟内存是底层物理内存的映射，因此可以通过其将进程重定位到物理内存的任意位置
虚拟内存子系统主要成分为虚拟地址空间。CPU自带一个将内存逻辑地址转换为物理地址的硬件电路，并且有一组页表来表示虚拟与实际的对应关系。
Unix将RAM分为两部分，一部分是系统占用（内核代码和内核数据结构），另一部分是由虚拟内存处理。而32位和64位的内存架构是不同的，其架构组成部分如下所示
	DMA：内存中小于16MB的区域，历史原因。曾经有些硬件只能运行在该区域
	DMA32：内存低于4G的区域，只存在与64位架构上。在32位到64位过渡时期，有些只能运行在该区域
	Normal：64位机器上，大于4G的区域全都是该块。32位机器上，从16MB-896MB的区域是该快（历史原因）
	HighMem：只存在32位系统，4G区域。
内核有一个分配内存的子系统-内核内存分配器（Kernel Memory Allocator，KMA）其致力于以下几个目标：
	1.快
	2.浪费内存降低到最小
	3.减少内存碎片
	4.能够被其他内存管理子系统调用
基于不同算法，有以下几种KMA:
	1.Buddy系统
	2.Solaris的Slab分配算法
	等等
内核为进程分配的虚拟内存地址空间包括以下几个部分：
	1.程序的可执行代码
	2.程序的初始化数据
	3.程序的未初始化数据
	4.初始程序栈（用户态栈）
	5.所需共享库的可执行代码和数据
	6.堆（程序动态请求的内存）
Unix操作系统的内存分配策略都是基于 请求调页。进程访问一个不存在页时，MMU产生一个异常，异常处理程序定位到受影响的内存区，为其分配一个空闲页。并用适当的数据将其初始化。同理，当系统动态请求内存时，内核只会修改进程的堆内存大小，等到真正试图引用内存页时才会引起异常，并为其分配页。
