  CPU在一个时间点只能处理一个进程，进程一般运行在用户态，当需要访问一些底层硬件资源时(例如 文件操作)需要从用户态切换为内核态。
然而当一个进程A正处于内核态被执行时，因为时间片等原因另一个进程B拿到了CPU使用权。
原本处于内核态执行的进程A被挂起，其相关描述信息被从CPU相关寄存器中刷掉，原来存放在寄存器中的数据内容将被保存在“进程描述符”中。
当进程A再次获取CPU使用权时，寄存器会从“进程描述符”中拿去相应的数据。
  在上述的过程中。进程A在内核态挂起，因为Linux内核的可重入性，内核态中可以有多个进程存在。
然而当内核态中多个进程都对同一个资源文件进行调用时，如果是“读”调用没有什么影响，进程间可以通过“共享内存”技术来节省该调用文件的
内存占用。但是如果同时对资源文件进行“写”操作时就会有很大的问题。这就涉及到“可重入内核”的“同步机制”，
如果内核控制路径(表示内核系统调用，异常中断等一系列的指令)对某个内核数据结构进行操作被挂起时，其他的进程的内核控制路径
不应再对该数据结构进行操作，否则会引起“不一致性”问题，引起重大事故。
Linux采用临界区方式来解决。对全局资源采用“原子操作”，对数据的操作时单独的，不能中断的。
对一个资源进行操作时会进入到一个临界区，在进入临界区前禁止抢占，退出临界区可以抢占。
在临界区中的操作必须完成的。然后另外一个进程的资源操作才能进行。而对于同步问题的解决方式，一般有以下几种方式：
        1.非抢占式内核：只有当内核态的进程自愿放弃CPU时，其他进程才能接手，多核条件下，性能低下。
	2.禁止中断：在进入临界区前禁止所有硬件中断，效果不佳。如果临界区较大，会使很多硬件设备假死。
          除此之外，多核条件下，只禁止本地CPU中断不够。
	3.信号量：每个信号量为一个对象，其包含有一个等待队列和整数变量以及一个down(对整数变量减1)和一个up(对整数变量加1)原子操作。
          当整数变量的值大于或等于0，则代表该数据结构能够调用，如果为负则不可调用，如果有进程访问将其加入到等待队列中。
          该方法如果临界区较小时，性能会不太好。刚刚加入到队列就要出来
        4.自旋锁：当一个进程调用某数据结构时，该数据结构上锁，其他进程发现锁之后，一直循环的调用，直到该锁解除。
          单处理器无效，因为同一时间只能处理一个进程，循环是来回切换的，无效。
