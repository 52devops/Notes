# 概念
## 内存架构
### 32位内存结构区域
- ZONE_DMA(0-16MB)
- ZONE_NORMAL(16MB-1GB)
  - 保留区域(896MB-1GB)
  用于映射ZONE_HIGHMEM的地址
- ZONE_HIGHMEM(1GB-64GB)

### 64位内存结构区域
- ZONE_DMA(0-1GB)
- ZONE_NORMAL(1GB-64GB)

## 内存管理
为了提高内存的管理，目前系统使用`分页(page)`技术对内存进行管理
分页将内存划分为固定的chunk，分页的大小由CPU架构决定，一般x86和i386为4KB
物理内存被分成`页帧(page frame)`。一个页帧包含数据的一个分页
进程不能直接对物理内存寻址，为一个进程分配内存时会将页帧的物理地址映射到进程的地址空间，表现为虚拟的地址(每个进程都有地址空间)
进程只能访问自己的私有地址空间，虚拟空间大小由CPU架构决定。但是进程不会一次性的占用所有地址空间(物理地址未映射，未分配)。
32位地址空间2^32B(4G),其中用户空间区域为**0-3G**，内核空间区域**3G-4G**
64为地址空间2^64B(16EB),用户空间和内核空间无限制

### 页的分配
一个分页是页帧或虚拟内存的一个线性地址。内核以内存页为单位处理内存
当进程请求一定数量的内存页时，如果剩余内存量充分，将会立刻分配。否则会从其它程序或分页缓存中得到。

### 页的回收
当请求到来，却没有有效分页时。内核将释放一定数量的页(之前使用，但目前因为某些原因被标记为不活跃的页)，然后将这些页分配给请求的进程。  
通过内核线程`kswapd`和内核函数`try_to_free_page()`进行上述的分页回收。
`kswapd`线程平时处于可中断睡眠状态，当区域空闲分页少于一个阈值，会被激活。基于`最近最少(Least Recently Used LRU)`原则释放分页。
### 虚拟内存管理
对于进程来说，其调用的都是内核映射给他们的虚拟内存，因此进程并不知道虚拟内存至下到底是真正的内存还是来自磁盘的`swap虚拟内存`  
kswapd扫描活跃分页的列表，将最近没使用过的放入非活跃分页列表。  
分页回收发生时，非活跃列表中的`进程地址空间`的候选分页会被`page out`。  
有时，page out操作只是为了保证主内存的分配。比如内存分页已经用完，但是某进程时间片还有很多，就会将其进行page out  
所以swap较高也不一定是性能不足，只是为了更好的利用系统资源  
`vmstat -a`显示活跃和分活跃分页数
除此之外，kswapd回收分页时宁可缩小分页缓存大小也不愿意对进程分页进行`page out`或`swap out`操作  
- page out
将地址空间的一部分分页移动到swap中
- swap out
将整个地址空间放入swap  
> kswapd 回收分页缓存或者回收进程地址空间会根据不同场景来进行。具体可以使用/proc/sys/vm/swappiness来控制
### Buddy System
维护内存分页，将较小临近的分页合并为一个较大的分页  
`cat /proc/buddyinfo`可以查看buddy的相关状态信息




