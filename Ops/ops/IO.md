# 概念
在处理器执行命令前，数据会从磁盘盘片的扇区上被检索到处理器的缓存和它的寄存器中。执行后通过一系列IO调度将其写回磁盘  

## 写入数据的过程
- 进程调用`write()`请求写文件
- 内核更新文件映射的分页缓存
- 内核线程使用pdflush/Per-BDI flush 将分页缓存刷到磁盘上
- 文件系统层同时在一个`bio Block input output`结构中放置每个块缓冲，并向块设备提交写请求
- 块设备层得到请求，执行IO电梯操作，将请求放置到IO请求队列
- 设备驱动器执行写操作
- 磁盘设备的固件执行硬件操作，磁头开始旋转定位数据传输

因为写入速度的差异，为了更快的提高性能。一般会用到使用到缓存机制，越高的缓存命中率对性能的提升也是越大的  
目前使用的缓存机制使`参考局部性`原则
- 大多数最近刚使用过的技术，不久的未来有较高几率可能再次使用(时间局部性)
- 驻留在数据附近的数据，有较高几率再次被使用(空间局部性)
> Linux 许多组件中都使用该机制，如分页缓存、文件对象缓存、预读缓冲等  
### 脏页
进程从缓存中检索相应的数据，如果需要改变数据，会先改变内存中的数据。这时磁盘数据与内存数据不一致，内存中的数据就称为`dirty page(脏页)`  
脏页的数据会使用`pdflush/Per-BDI`刷新到磁盘上，否则如果断电会引起数据丢失。一般内存中脏页超过一定阈值时会执行刷新  
### 块层
块层处理所有有块设备操作有关的活动。块层的bio是文件系统与块层之间的一个接口，是其关键的数据结构    
写操作时，文件系统尝试将写入放到由`块缓存区`构成的`分页缓存`,然后将其发送到块层  
块层处理这些bio请求，并将这些请求放入`IO请求队列`，这个放入的过程称为`IO电梯调度`  
#### IO电梯调度模型
##### CFQ 完全公平队列
为每个进程维护一个IO队列，积极避免进程饿死，具有低延迟特征  
各个队列之间通过时间片来调度，保证公平。适用于多程序IO并发系统  
一次执行一个进程的4个请求  
##### Deadline
循环电梯调度，近似于实时的IO子系统，提供了优秀的对块设备扇区的顺序访问，又保证进程不会再队列中等待太久饿死  
为了保证既能顺序访问，又能不饿死。Deadline的机制如下
- Deadline有4个队列，两类
- 每一类分别由读写两队列组成
- 一类队列按照请求的扇区排序(红黑树组织) sort_list
- 另一类队列按照请求生成时间排序(链表组织) fifo_list
所有请求在创建时都会被赋一个期限值，并按照期限制排列在`fifo_list`中,读操作期限500ms、写操作5s。在Deadline调度器中还有一个`writes_starved`的标准参数，默认为`2`。当饿死进程的次数超过`writes_starved`时才会考虑写请求。  
因此即使一个写请求已经超过了期限，也不一定回立刻响应。即使处理完，也要等饿死进程的次数超过`writes_starved`。因为读请求会造成进程的阻塞，而写进程只是要将分页缓存中的数据写入磁盘而已，失不失败无所谓。  
每当确定要执行某进程的读或写方向后，会从sort_list中将一批连续的请求调度到请求队列中，具体数目由`fifo_batch`决定  
出现以下情况会使一次批量传输结束  
- 对应的sort_list中已为空
- 下一个请求扇区不满足递增
- 上一个请求已经是这一次批量传输中的最后一个
> Deadline 适合多程序在磁盘上执行**大量IO操作**  
##### NOOP
无操作，没有额外的骚操作。只是一个FIFO队列，一般是底层存储拥有自己的算法时会使用

