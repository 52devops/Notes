# IP报文就是 在应用发出的数据报文中封装了IP首部的数据包。
## TCP/IP 模型
- 应用层
- 传输层   TCP报文段/TCP段  UDP数据报
- 网络层   IP数据报
- 链路层   帧		设备驱动及接口卡
## 以太网帧结构
段名|以太网首部|IP首部|TCP首部|应用数据|以太网尾部|总计|
----|----|----|----|----|----|----|
字节数|14|20|20| |4|46至1500|  

**如果TCP换为UDP，UDP数据报首部长8字节**
- ICMP：IP协议附属协议，用来与其他主机或路由器交换错误报文和其他重要信息
- IGMP：Internet组管理协议，将UDP数据报多播到多个主机
- ICMP和IGMP都是IP的附属协议，但是都会被封装在IP数据报里。
- SLIP：串行线路，有1位起始比特和1位结束比特
## IP一共32位，其中32位由 网络ID 及主机ID组成
地址种类|组成结构(二进制)|网络号|计算方式|网段|私有地址|
----|----|----|----|----|----|
A类地址|0-7位网络号-24位主机号|00000000.|0*2^7+0*2^6+0*2^5+0*2^4+0*2^3+0*2^2+0*2^1+0*2^0 =0|0.0.0.0至127.255.255.255|10.0.0.0至10.255.255.255<br>127.0.0.0至127.255.255.255|
B类地址|10-14位网络号-16位主机号|10000000.|1*2^7+0*2^6+0*2^5+0*2^4+0*2^3+0*2^2+0*2^1+0*2^0=128.|128.0.0.0至191.255.255.255|172.16.0.0至172.31.255.255|
C类地址|110-21位网络号-8位主机号|11000000.|1*2^7+1*2^6+0*2^5+0*2^4+0*2^3+0*2^2+0*2^1+0*2^0=192.|192.0.0.0至223.255.255.255|192.168.0.0至192.168.255.255|
D类地址|1110-28位多播组号|11100000.|1*2^7+1*2^6+1*2^5+0*2^4+0*2^3+0*2^2+0*2^1+0*2^0=224.|224.0.0.0至255.255.255.255|255.255.255.0|

**十进制IP转化为二进制八位IP**
```
207.207.207.207
如果207大于2^7 就写下1.减去128，如果小于128 写下0  减去0        207-128=79    1
得到的差值大于64 就写下1.减去128，如果小于，写下0  减去0        79-64=15      1
一直减到  2^0次方。
用该方法算出
二进制八位IP为 1100111.1100111.1100111.1100111
```

**报头结构  逻辑上分段（层），每次传输从左(0)到右(31)传输，一次8bit**
**最小20字节。IP报头基础层有5层，每一层为32bit。所以这样计算  (32/4)*5=20**
- 第一层
  - 版本号(4 bit) 
  - IHL(Internet Header Length 4 bit):首部占32bit的数目,就是多少个32bit。32bit=4字节。因为其为4位，所以IP首部最大为15*32/4=60字节
  - 服务类型TOS(8 bit 其中3bit优先权子字段(现在已经不用) 4bit 服务种类有分别代表，最小延迟、最大吞吐量、最高可靠性、最小费用。四项只能	  选1项，选中哪项置1。剩下1bit未用，置0)
  - 总长度(16 bit IP数据报的总长度):最大长度为65535，当数据报被分段时，该值随着改变。
- 第二层
  - 标识(16 bit 依次变大的数值)，将较大的数据报拆分为多个数据报，将利用这个标识序号来决定包顺序 
  - 标志位(3 bit 标识分段 第一位 为空 第二位DF不分段  第三位 MF更多分段) 
  - 分段位移(13 bit 使用该值来重组分段)
- 第三层
  - TTL（8 bit 能够经过路由器的跳数/在被丢弃前的保留时间，秒为单位）
  - 协议(8 bit 表明接收数据的协议) 
  - 报头校验和(16 bit 用于检测报头本身有效性，经过一个路由就会算一次。接收方接受到后该值应该都为1
- 第四层
  - 源IP（32位）
- 第五层
  - 目的地址(32位)
- 第六层
  - IP选项(可以选择一些报头设置，记录传输路径，网际时间戳，安全限制)， 为了保证该层长度为32有时候才用0填充
- 第七层
  -数据
![报头结构](http://orh0ftvwf.bkt.clouddn.com/%E6%8A%A5%E5%A4%B4%E7%BB%93%E6%9E%84.jpg)

IP从本地应用产生的数据包、或者网络接口接受的数据包（待转发的数据包）。然后根据目的地址，及本机IP路由表来进行搜索，检测目的地址是否为本机IP
或IP广播地址。如果是 数据报会由IP首部中指定的协议模块进行处理发送。如果不是，那么本机IP会变为路由转发功能。
路由转发规则：
	1，搜索
ARP  IP->MAC寻址
RARP MAC->IP寻址
SLIP：串行线路IP、点对点通信。

子网掩码与IP中的每一位都是相互对应，子网掩码中1表示IP地址中网络/子网ID,用0表示IP地址中的主机ID位
CIDR（无类别域间路由）类似于子网掩码，又不同于子网掩码。可以将几个大段的IP地址，化为一个子网段。抛弃了 N类网络的概念。


![TCP包结构](http://orh0ftvwf.bkt.clouddn.com/TCP%E5%8C%85%E7%BB%93%E6%9E%84.jpg)
- 第一层
  - src源地址（16）
  - dest目的地址（16）
- 第二层
  - 序列号（32）
- 第三层
  - 确认号（32）
- 第四层
  - 数据偏移（4）
  - 保留（6）
  - 控制标记（每个1位，分别有URG,ACK,PSH,RST,SYN,FIN）  
  - URG 为1表明该数据分段为“紧急的”,PSH：“为1时，让让TCP把目前收到的全部数据都通过管道传给接收的应用程序”，PST“为1时会重置连接”
  - 窗口（16位）：用于流量控制参数，定义发送序列号可以超过已确认序列号。
- 第五层
  - 校验和（16） 检验数据分段的完整性。
  - 紧急指针（16）偏移量，如果URG为1 ，会标记处紧急信息开始的序号。

UDP：没有TCP那么多的额外功能（流量控制，分段排序，差错校验等），身为无连接方式会被用于 网络广播所使用的协议
UDP头包只有逻辑上的3层
- 第一层
  - 源端口（16）
  - 目的端口（16）

- 第二层
  - 长度（16）表示UDP数据报长度
  - 校验和（16）校验数据传输中是否损坏。校验和基于伪报头、UDP报头、UDP数据和填充0计算
- 第三层
  - 数据（长度可变）
实际UDP报头不包含源IP地址，目的IP地址。但再开启UDP校验时会有一个**伪报头**。包含32位源IP地址，32位目的IP地址，8位协议，8位0填充，16位UDP长度。<br>通过伪首部的校验，UDP可以确定该数据报是不是发给本机的，通过首部协议字段，UDP可以确认有没有误传

环回接口：任何数据都作为IP输入，并且该链路被视为网络层之下的一个链路层，会经过传输层和IP层。网络层把数据报传送给环回接口，就像传给其他链路层一样，不过环回接口把它返回到IP输入队列中。
当数据报大于MTU（最大传输单元）时，IP层要对其进行分片
在传播数据报时,因为有不同的传播链路。其中每个设备的MTU都可能不相等，会采用设备中最小的MTU值（路径MTU）。通过ICMP、IP分片方法发现链路路径MTU
 
IP层：无连接（IP并不维护任何关于后续数据报的状态信息，每个数据报的处理相互独立）、不可靠（不能保证IP数据报能成功到达目的地，仅提供尽力而为的传输服务。如果发生错误，会发送ICMP消息报给信源端，可靠性由上层决定）
 
ARP代理：从一个网络发往另一个网络，连接诶这两个网络的路由器能够响应该ARP请求，这种形式就是ARP代理
当arp中出现两个相同的MAC地址时，有可能是因为使用了ARP代理，两个网络，两网络机器通过SLIP互联，导致对方网络ARP都经过这两机器中自己的一端跳往堆段，ARP反映的就是该台机器MAC
## 免费(gratuitous)ARP：主机发送ARP查找自己的IP地址
- 作用： 
  - 1.查找是否有与自己相同的IP地址 
  - 2.发送免费ARP的主机正好改变自己硬件地址（更换网卡）
RARP：应用于利用MAC来得到IP.(PXE)  RARP发出是广播方式，reply是单播。一旦MAC的主机收到IP，会发出TFTP请求。
ICMP: IP附属协议，分为差错报文和查询报文两类。对差错报文进行响应，无论遇见什么错误都不会再生成一份差错报文。
STP: Spanning tree protocol 协议，在网络中构建一个逻辑上的无环路树状拓扑结构。基础的功能是用来解决网桥环路已经广播风暴这些问题。

# ICMP报文
![ICMP的结构](http://www.embeddedlinux.org.cn/linux_net/0596002556/images/understandlni_2501.jpg)
- 第一层	
  - 8位类型 
  - 8位代码
  - 16位校验和
**下来的层级根据不同类型服务代码有不同的内容**
```
最常见的为例
	类型 0  代码 0  代表 ping.reply
	类型 8  代码 0  代表 ping.echo request
	其结构为
	第一层	类型0/8 代码0 校验和（16）
	第二层	标识符(16 bit) 序号(16 bit)
	第三层	选项数据
```
Unix系统通常把发送进程的PID置为ICMP报文中的标识符，这样即使并发执行ping程序，ping程序也能区分返回信息。
序号从0开始，每发送一次新的回显请求就加1、利用该序号可以查看是否数据包有丢失、失序、重复等问题。
ping请求的往返时间(RTT)利用应答返回时的本机时间减去ICMP报文中的发送请求时间来计算。另外可以使用 -R选项开启RR模式（有些路由器不支持），记录
其经过的路由。其方式为：
	经过一个路由，会把其IP地址放到 选项数据中，达到目的地址后 echo reply 会把这个信息复制到 echo reply的选项数据中，然后回复
	路径仍然继续，直到达到Client端显示出来（只能记录9个）功能与Traceroute类似。
- 为了避免ICMP差错报文对广播分组相应所带来广播风暴，有几种情况不产生差错报文
  - ICMP差错报文
  - 目的地址是广播地址
  - 链路层广播的数据报
  - 不是IP分片的第一片
  - 源地址不是单个主机(不为0.0.0.0/127.0.0.1/广播地址/组播地址)的数据报


- Traceroute
```
	ping -R 命令的高级版。不需要各个路由器将地址记录到 ICMP.echo.request
	使用ICMP报文和IP首部的TTL
	原理：
		Traceroute发送一个TTL为1的IP数据报给目的主机（每个TTL发三份ICMP报文），当第一个路由器接收到后将TTL减1，TTL=0丢弃，并发回一份超时ICMP报文
		这样就知道该路径第一个路由器，然后依次增加TTL数值进行传输。直到数据报到达目的地址。如果在默认的Traceroute时间内（5s）没有收到一个响应报文，则就打印"*"号。Traceroute UDP报文将目的端口设为
		一个不可能使用的端口，当报文到达目的地址后会触发“端口不可达”的错误，触发该错误会证明到达目的地址。
		可以指定经过的路径网关（最多9个，但是指定时只有8个。因为最后一个是目的地址），这种方式分为模式：
			1.严格的源路由选择(SSRR)：必须按照规定的网关路由进行传递
			2.宽松的源站选择(LSRR)：只要经过规定的路由就行，两个规定的路由之间的传递可以经过其他路由。
ICMP如果不被转发路由的话，会返回一个“主机不可以达差错”、“网络不可达差错”。
```


