# GIL全局锁
在同一时间内，确保只有一个线程在运行。  
IO密集型的操作GIL会释放，允许这个在IO阻塞时其它线程进行操作。  
非IO密集线程会倾向于整个时间片始终占有CPU  
因此IO不密集的python单一进程拥有多线程是没有太大作用  
# 多线程
## 库
**_thread**  
测试实验用较多，偏底层
**threading**  
实现一个`Thread`类，可以通过调用该类或集成该类对某些方法重写进行处理  
该模块还支持守护线程，守护线程一般是不重要，只是用来等待客户端连接  
进程退出时不用等待守护线程工作的完成，换句话来说当子线程任务完成时就退出    
一般使用该模块，用两种方法实现多线程  
- 创建`Thread`类，为其传入函数及参数
- 派生Thread子类
  - run() 定义线程功能
  - start() 开始执行线程
## 同步
同步是为了解决**竞态条件**的情况，因为某些场景的某些操作不希望使用多线程同时执行  
如修改数据库等能够产生**竞态条件的类似情况**  
使用同步时，能够在给定时间点内只允许一个线程通过  
### 锁同步
锁的机制只有两种，加锁和释放锁  
当多线程抢夺锁时，其允许第一个获得锁的进入临界区，执行代码，其它后面线程将会被阻塞，直到其释放锁  
从获得锁的开始到锁释放只能有一个线程在干活  
```
lock = Lock()
lock.acquire()
xxx
xxx
lock.release()
或者使用上下文管理功能，在进入该功能时会自动调用acquire()，执行完后会自动release()

lock = Lock()
with lock:
    xxx
    xxx
```  
### 信号量
在较为复杂的情况，可以使用更为高级的同步原语如 信号量  
信号量是比较古老的同步原语之一，是一个计数器。  
当资源消耗时递减，资源释放时递增  
消耗资源使计数器递减的操作一般称为`P()`,也叫做wait、try、acquire、pend、procure  
一个线程对一个资源完成操作时，资源返回资源池中。这个操作称为`V()`或signal、increment、release、post、vacate  
信号量比锁更灵活，可以有多个线程，每个线程拥有相应资源的一个实例  
### 生产者-消费者问题
通过队列进行中转传输  
## 线程安全
python原子性的操作会保证线程的安全，但非原子性操作不能保证，需要额外的进行锁控制
