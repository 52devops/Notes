# 正则
## 匹配符
与Linux不同，区分了贪婪和非贪婪匹配。其正则符号与Linux类似，容易忘的有下面几个。
- * 匹配0至无数次前导字符或表达式
- + 匹配1至无数次前导字符或表达式
- ? 匹配0至1次前导字符或表达式
- | 择一，选左边内容或右边
- \w 匹配所有字符、数字、字母
- \d 匹配数字  \W与其相反
- \s 匹配任何空格字符，\S与其相反
- (?:正则) 将一部分正则匹配的内容作为该子组，匹配后直接不保存该分组，忽略掉。
- (?P<key>) 将匹配到的子组作为该key的value，返回字典，.groupdict 

## 断言
- (?=xx) 如果一个字符串尾部为xx，才做匹配，并不保存括号内容
- (?!xx) 如果一个字符串尾部不为xx，才做匹配，并不保存括号内容
- (?<=xx) 如果一个字符串前为xx，才做匹配，并不保存括号内容
- (?<!xx) 如果一个字符串前不为xx，才做匹配，并不保存括号内容

## 标记
该参数能够让re模块在匹配时进行额外的操作。如忽视字符串大小写，忽视换行符等。以下均为简写
- re.I 忽略大小写
- re.L L=locate 根据本地语音编码进行匹配
- re.M ^ $两符号对应每一行的开始和结束
- re.S "."符号默认不能匹配换行符，使用该参数能够匹配换行符
- re.X 除了前面有转义付的空格，其他都会自动注释。<br>
**如果使用多个标记，则其格式为 "(?iLmsux)" 可以在正则表达式中写入(?i)T 这个代表忽视T的大小写**

## 模块
- match 匹配，从开头开始匹配
- search 搜索整句，搜索到第一次匹配的停止返回。
- findall 查找所有(非重复)字符串，返回一个匹配列表
- finditer 与findall一样，但返回一个可迭代器
- split 根据正则分隔字符
在正则中"()"保存子组，比如

```
p = (\w-\w-\w)-(\d-\d-\d)
b = re.match = (p,'a-b-c-1-2-3')
这种情况时，match函数会分别(\w-\w-\w)和(\d-\d-\d)对字符串匹配，形成两个子分组放入b.group(1),b.group(2)。
```
