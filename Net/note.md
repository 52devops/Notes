# IP报文就是 在应用发出的数据报文中封装了IP首部的数据包。
## TCP/IP 模型
- 应用层
- 传输层   TCP报文段/TCP段  UDP数据报
- 网络层   IP数据报
- 链路层   帧		设备驱动及接口卡

- 常见概念
  - ARP  IP->MAC寻址
  - RARP MAC->IP寻址
  - SLIP：串行线路IP、点对点通信。有1位起始比特和1位结束比特
  - RARP：应用于利用MAC来得到IP.(PXE)  RARP发出是广播方式，reply是单播。一旦MAC的主机收到IP，会发出TFTP请求。
  - ICMP: IP附属协议，分为差错报文和查询报文两类。对差错报文进行响应，无论遇见什么错误都不会再生成一份差错报文。
  - STP: Spanning tree protocol 协议，在网络中构建一个逻辑上的无环路树状拓扑结构。基础的功能是用来解决网桥环路已经广播风暴这些问题。
  - ICMP：IP协议附属协议，用来与其他主机或路由器交换错误报文和其他重要信息
  - IGMP：Internet组管理协议，将UDP数据报多播到多个主机
  - ICMP和IGMP都是IP的附属协议，但是都会被封装在IP数据报里。
  - SLIP：  - ARP代理：从一个网络发往另一个网络，连接诶这两个网络的路由器能够响应该ARP请求，这种形式就是ARP代理。当arp中出现两个相同的MAC地址时，有可能是因为使用了ARP代理，两个网络，两网络机器通过SLIP互联，导致对方网络ARP都经过这两机器中自己的一端跳往堆段，ARP反映的就是该台机器MAC
  - 环回接口：任何数据都作为IP输入，并且该链路被视为网络层之下的一个链路层，会经过传输层和IP层。网络层把数据报传送给环回接口，就像传给其他链路层一样，不过环回接口把它返回到IP输入队列中。
  - 以太网首部：14字节
  - 以太网尾部：4字节
```
当数据报大于MTU（最大传输单元）时，IP层要对其进行分片
在传播数据报时,因为有不同的传播链路。其中每个设备的MTU都可能不相等，会采用这条传输设备中最小的MTU值（路径MTU）利用ICMP差错报文。通过ICMP、IP分片方法发现链路路径MTU
子网掩码与IP中的每一位都是相互对应，子网掩码中1表示IP地址中网络/子网ID,用0表示IP地址中的主机ID位
CIDR（无类别域间路由）类似于子网掩码，又不同于子网掩码。可以将几个大段的IP地址，化为一个子网段。抛弃了 N类网络的概念。
```

## 以太网帧结构
段名|以太网首部|IP首部|TCP首部|应用数据|以太网尾部|总计|
----|----|----|----|----|----|----|
字节数|14|20|20| |4|46至1500|  

**如果TCP换为UDP，UDP数据报首部长8字节**
## IP一共32位，其中32位由 网络ID 及主机ID组成
地址种类|组成结构(二进制)|网络号|计算方式|网段|私有地址|
----|----|----|----|----|----|
A类地址|0-7位网络号-24位主机号|00000000.|0*2^7+0*2^6+0*2^5+0*2^4+0*2^3+0*2^2+0*2^1+0*2^0 =0|0.0.0.0至127.255.255.255|10.0.0.0至10.255.255.255<br>127.0.0.0至127.255.255.255|
B类地址|10-14位网络号-16位主机号|10000000.|1*2^7+0*2^6+0*2^5+0*2^4+0*2^3+0*2^2+0*2^1+0*2^0=128.|128.0.0.0至191.255.255.255|172.16.0.0至172.31.255.255|
C类地址|110-21位网络号-8位主机号|11000000.|1*2^7+1*2^6+0*2^5+0*2^4+0*2^3+0*2^2+0*2^1+0*2^0=192.|192.0.0.0至223.255.255.255|192.168.0.0至192.168.255.255|
D类地址|1110-28位多播组号|11100000.|1*2^7+1*2^6+1*2^5+0*2^4+0*2^3+0*2^2+0*2^1+0*2^0=224.|224.0.0.0至255.255.255.255|255.255.255.0|

**十进制IP转化为二进制八位IP**
```
例如转换207.207.207.207
如果207大于2^7 就写下1.减去128，如果小于128 写下0  减去0        207-128=79    1
得到差值大于64 就写下1.减去128，如果小于64，写下0  减去0        79-64=15      1
一直减到  2^0次方。
用该方法算出
二进制八位IP为 1100111.1100111.1100111.1100111
```

## IP报头结构
**每次传输从左(0)到右(31)传输，一次8bit**
**最小20字节。IP报头基础层有5层，每一层为32bit。所以这样计算  (32/4)*5=20**
```
IP层：无连接（IP并不维护任何关于后续数据报的状态信息，每个数据报的处理相互独立）、不可靠（不能保证IP数据报能成功到达目的地，仅提供尽力而为的传输服务。
如果发生错误，会发送ICMP消息报给信源端，可靠性由上层决定
IP从本地应用产生的数据包、或者网络接口接受的数据包（待转发的数据包）。然后根据目的地址，及本机IP路由表来进行搜索，检测目的地址是否为本机IP
或IP广播地址。如果是 数据报会由IP首部中指定的协议模块进行处理发送。如果不是，那么本机IP会变为路由转发功能。
```
![报头结构](http://orh0ftvwf.bkt.clouddn.com/%E6%8A%A5%E5%A4%B4%E7%BB%93%E6%9E%84.jpg)
- 第一层
  - 版本号(4 bit) 
  - IHL(Internet Header Length 4 bit):首部占32bit的数目,就是多少个32bit。32bit=4字节。因为其为4位，所以IP首部最大为15*32/4=60字节
  - 服务类型TOS(8 bit 其中3bit优先权子字段(现在已经不用) 4bit 服务种类有分别代表，最小延迟、最大吞吐量、最高可靠性、最小费用。四项只能	  选1项，选中哪项置1。剩下1bit未用，置0)
  - 总长度(16 bit IP数据报的总长度):最大长度为65535，当数据报被分段时，该值随着改变。
- 第二层
  - 标识(16 bit 依次变大的数值)，将较大的数据报拆分为多个数据报，将利用这个标识序号来决定包顺序 
  - 标志位(3 bit 标识分段 第一位 为空 第二位DF不分段  第三位 MF更多分段) 
  - 分段位移(13 bit 使用该值来重组分段)
- 第三层
  - TTL（8 bit 能够经过路由器的跳数/在被丢弃前的保留时间，秒为单位）
  - 协议(8 bit 表明接收数据的协议) 
  - 报头校验和(16 bit 用于检测报头本身有效性，经过一个路由就会算一次。接收方接受到后该值应该都为1
- 第四层
  - 源IP（32位）
- 第五层
  - 目的地址(32位)
- 第六层
  - IP选项(可以选择一些报头设置，记录传输路径，网际时间戳，安全限制)， 为了保证该层长度为32有时候才用0填充
- 第七层
  -数据<br>

# TCP
## TCP报头结构
```
校验和覆盖整个TCP报文段，首部和数据段都有。校验时会有和UDP一样的伪首部。
```
![TCP包结构](http://orh0ftvwf.bkt.clouddn.com/TCP%E5%8C%85%E7%BB%93%E6%9E%84.jpg)
- 第一层
  - src源端口（16）
  - dest目的端口（16）
- 第二层
  - 序列号（32）
- 第三层
  - 确认号（32）
- 第四层
  - 数据偏移（4）
  - 保留（6）
  - 控制标记（每个1位，分别有URG,ACK,PSH,RST,SYN,FIN）  
    - URG 为1表明该数据分段为“紧急的”
    - PSH 为1时，让让TCP把目前收到的全部数据都通过管道传给接收的应用程序”，
    - PST 为1时会重置连接”
  - 窗口（16位）：用于流量控制参数，定义发送序列号可以超过已确认序列号。
- 第五层
  - 校验和（16） 检验数据分段的完整性。
  - 紧急指针（16）偏移量，如果URG为1 ，会标记处紧急信息开始的序号。
## 三次握手 and 四次分手
- 三次握手
  - 建立连接的双方确定MSS最大报文段长度，如果有一方不接受。那么就使用默认536字节。这样加上IP头和TCP头 又是576字节IP数据包<br>
  - 只有在第三个报文段，也就是最后一次握手后应用层才知道该链接建立。在这之前发送的数据都会放入缓冲队列中。
ISN 初始序列号
第一个SYN包会包含开始的序号，以及隐含结尾的序号(数据为0时)只有在报文段至少包含一个数据字节或SYN，FIN,RST置一时显示。
**三次握手**<br>
![三次握手](http://s4.51cto.com/wyfs02/M00/75/A5/wKiom1Y__jfCibe6AAAr9T4KX6s781.png)
- 四次分手
  - 四次分手的原理是因为TCP是全双工，两端都能够发送数据。所以需要两端都断开连接。如果只有一端发送了FIN，那么另外一段仍可以向这端发送数据。
  - 四次分手的TIME_WAIT又称为2MSL等待状态。每个TCP报文段都有一个最大生存时间MSL(Max segment Lifetime),TIME_WAIT的时间为2个MSL是防止ACK丢失。另一端可以再发。
  - 2MSL只发生在主动发起关闭的一方，一般服务器不会处在该状态。当处于2MSL状态时该端口不在接收任何请求!所以当服务器的某服务主动关闭，重启时端口是不可能马上开启。但是目前应用通过一些技术屏蔽掉了该问题。
  - 一个包中可以包括多个连接标志
**四次分手**<br>
![四次分手](http://s5.51cto.com/wyfs02/M01/75/A3/wKioL1Y__oeyXYjLAAAuUhKuLQs507.png)
## TCP功能
- 点对点，连接服务
- 定时器。发出一个段就会启动一个定时器，在默认时间内没有收到ACK就重传
- 强制性的首部和数据校验和。端到端的检测，如果不一致丢弃重传
- 能够对收到的数据重新排序
- 能够丢弃重复数据
- 提供流量控制，TCP连接每一方都有固定大小的缓冲区，只允许对端发送缓冲区能接受的大小
##  呼入队列请求
> 服务器调用新进程来处理每个客户的请求。该进程处于被动状态，时刻准备接受连接请求。如果服务器正处于繁忙状态，客户端请求建立连接时TCP有一下策略：
```
等待连接请求一端有一个固定长度连接队列。队列中连接已经三次握手成功，但应用层没有接受，如果接受会从移出该队列。
该队列称为backlog，积压值，大小由应用层指定，一般为0-5
一个连接到达时TCP根据当前队列的连接数来决定是否接受该链接。
```

## UDP报头结构
```
UDP报头不包含源IP地址，目的IP地址。但当开启UDP校验时会有一个**伪报头**,只覆盖头部。包含32位源IP地址，32位目的IP地址，8位协议，8位0填充，16位UDP长度。
通过伪首部的校验，UDP可以确定该数据报是不是发给本机的，通过首部协议字段，UDP可以确认有没有误传
UDP数据报最大长度=2^16比特总长度-20IP首部-8UDP首部=65507字节
```
![UDP报头](http://flylib.com/books/3/223/1/html/2/files/11fig02.gif)
UDP：没有TCP那么多的额外功能（流量控制，分段排序，差错校验等），身为无连接方式会被用于 网络广播所使用的协议
UDP头包只有3层
- 第一层
  - 源端口（16）
  - 目的端口（16）
- 第二层
  - 长度（16）表示UDP数据报长度
  - 校验和（16）校验数据传输中是否损坏。校验和基于伪报头、UDP报头、UDP数据和填充0计算
- 第三层
  - 数据（长度可变）
 
## 免费(gratuitous)ARP：主机发送ARP查找自己的IP地址
- 作用： 
  - 1.查找是否有与自己相同的IP地址 
  - 2.发送免费ARP的主机正好改变自己硬件地址（更换网卡）

## ICMP报文
![ICMP的结构](http://www.embeddedlinux.org.cn/linux_net/0596002556/images/understandlni_2501.jpg)
- 第一层	
  - 8位类型 
  - 8位代码
  - 16位校验和
**下来的层级根据不同类型服务代码有不同的内容**
```
最常见的为例
	类型 0  代码 0  代表 ping.reply
	类型 8  代码 0  代表 ping.echo request
	其结构为
	第一层	类型0/8 代码0 校验和（16）
	第二层	标识符(16 bit) 序号(16 bit)
	第三层	选项数据

Unix系统通常把发送进程的PID置为ICMP报文中的标识符，这样即使并发执行ping程序，ping程序也能区分返回信息。
序号从0开始，每发送一次新的回显请求就加1、利用该序号可以查看是否数据包有丢失、失序、重复等问题。
ping请求的往返时间(RTT)利用应答返回时的本机时间减去ICMP报文中的发送请求时间来计算。另外可以使用 -R选项开启RR模式（有些路由器不支持），记录
其经过的路由。其方式为：
	经过一个路由，会把其IP地址放到 选项数据中，达到目的地址后 echo reply 会把这个信息复制到 echo reply的选项数据中，然后回复
	路径仍然继续，直到达到Client端显示出来（只能记录9个）功能与Traceroute类似。
```
- 为了避免ICMP差错报文对广播分组相应所带来广播风暴，有几种情况不产生差错报文
  - ICMP差错报文:很多种应用都用其作为，响应，数据包到达的响应标志。所有IP层的错误都会触发。
  - 目的地址是广播地址
  - 链路层广播的数据报
  - 不是IP分片的第一片
  - 源地址不是单个主机(不为0.0.0.0/127.0.0.1/广播地址/组播地址)的数据报


- Traceroute
```
	ping -R 命令的高级版。不需要各个路由器将地址记录到 ICMP.echo.request
	使用ICMP报文和IP首部的TTL
	原理：
		Traceroute发送一个TTL为1的IP数据报给目的主机（每个TTL发三份ICMP报文），当第一个路由器接收到后将TTL减1，TTL=0丢弃，并发回一份超时ICMP报文
		这样就知道该路径第一个路由器，然后依次增加TTL数值进行传输。直到数据报到达目的地址。如果在默认的Traceroute时间内（5s）没有收到一个响应报文，则就打印"*"号。Traceroute UDP报文将目的端口设为
		一个不可能使用的端口，当报文到达目的地址后会触发“端口不可达”的错误，触发该错误会证明到达目的地址。
		可以指定经过的路径网关（最多9个，但是指定时只有8个。因为最后一个是目的地址），这种方式分为模式：
			1.严格的源路由选择(SSRR)：必须按照规定的网关路由进行传递
			2.宽松的源站选择(LSRR)：只要经过规定的路由就行，两个规定的路由之间的传递可以经过其他路由。
ICMP如果不被转发路由的话，会返回一个“主机不可以达差错”、“网络不可达差错”。
```

# 分片
- IP分片
  - IP报头中有相关标识。如果分片，每一片都会有自己的IP首部，选路传输也独立进行。
  - IP分片一旦丢失一片数据会重传整个数据报。该机制为TCP机制，因为IP没有超时重传机制，TCP一旦丢失一个数据片会重发整个TCP报文段。UDP会经常触发分片，而TCP会避免分片。

