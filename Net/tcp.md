# TCP
靠谱的传输协议，首部20字节<br>
强制要求校验和,面向连接，控制避免分片
## TCP可靠性
应用数据被TCP切割为适合TCP传输的数据块，TCP封装后的数据称作**报文段/段**。该段的长度在三次握手时确立，双方各自汇报自己的MSS，如果有一方不接受，则会使用默认536字节，这样加上20字节IP首部和20字节TCP首部正好是576自己<br>
发出段后启动计数器，等待目的端口确认收到这个报文段，如**超时**，会重发。<br>
目的端收到后，会返回一个ACK，该ACK不是立刻发送<br>
TCP的校验和包括数据和首部，端到端的校验，如果检验和有错TCP将丢弃该报文段并不确认收到该报文段，此举将引起超时重发<br>
TCP能够处理IP数据报到达后的失序问题。将正确顺序交给应用层<br>
通过控制接收端缓冲区/窗口大小来进行流量控制，窗口大小在TCP首部中占16bit，因此窗口最大为65535字节<br>
## 建立连接和结束
建立连接通过三次握手方式<br>
结束通过四次分手<br>
因为TCP是全双工，所以需要四次分手，两端都需要发送一个FIN标准用来结束，如果只有一段发送那么进入半关闭状态，没有发送FIN那端仍可以发送数据，已发送FIN端仍可以接收数据。在主动关闭的一方收到ACK后会进入**TIME_WAIT**<br>
几个状态
- 建立连接
  - 连接端：
    - SYS_SENT
    - ESTABLISHED
  - 被连接端：
    - LISTEN
    - SYS_RCVD
    - ESTABLISHED
- 结束连接
  - 结束端
    - FIN_WAIT1
    - FIN_WAIT2
    - TIME_WAIT
  - 被结束端
    - CLOSE_WAIT
    - LAST_ACK
    - CLOSED
每个TCP报文段最大生存时间为MSL，指在被丢弃前在网络内的最长生存时间。
TIME_WAIT被称为2MSL等待，其MSL为2MSL.就是为了防止ACK丢失，另一端重发FIN，在这个等待时间任何刚到达的报文都会丢弃
平静时间：当节点处于2MSL状态时，发生故障重启。为了防止之前的报文被认为是新连接的包，则在MSL时间内不接受连接。但一般主机重启时间比MSL时间要长的多

##  呼入队列请求
> 服务器调用新进程来处理每个客户的请求。该进程处于被动状态，时刻准备接受连接请求。如果服务器正
处于繁忙状态，客户端请求建立连接时TCP有一下策略：
```
等待连接请求一端有一个固定长度连接队列。队列中连接已经三次握手成功，但应用层没有接受，如果接受
会从移出该队列。
该队列称为backlog，积压值，大小由应用层指定，一般为0-5
一个连接到达时TCP根据当前队列的连接数来决定是否接受该链接。
```
## TCP 数据传输
### 交互数据
每一次传输量较小。可以将每一次(每一字节)或每一行键入的数据作为TCP分组发送<br>
如果每次发送一次节的数据，那么TCP段长41字节(**微小分组**)会特别多，在广域网上太浪费，可能会造成拥塞。<br>Nagle算法解决了该问题，表示在TCP连接上最多只能有一个未被确认的小分组，该分组被确认前不能发送其他小分组。<br>TCP会在不能发送的时候收集这些小分组，将其合并，最终以一个分组发送
### 块数据
