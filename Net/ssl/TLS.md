# TLS概念
是一种密码学协议，用来为会话两端数据传输进行加密，认证等操作。<br>
分解两端的会话操作，可以看出会话是由由一个或多个消息组成的<br>
只用对这些消息进行加密解密处理即可<br>
## TLS 核心协议
上面提到对消息进行处理加密操作，其使用了TLS的**记录协议**，记录协议是TLS的基础协议<br>
记录协议工作在OSI的表示层中，负责对上下层传来的数据进行加密和解密操作<br>
TLS一次处理的数据类型被当做**一条TLS记录**<br>
每一条TLS记录有一个短的头(标头)，包含记录的子协议、协议版本、长度。<br>
### 记录协议核心知识
- 消息传输<br>
上下层的传来的数据会放在该一个缓存区中进行处理。缓存区大小如超过一个记录的长度(16384bytes)会分片。多个小的记录也会合并为一个
- 加密及完整性验证
在刚建立的连接上，最初传输没有加密和保护。否则双方都不能解密对方的消息，无法进行握手连接<br>
在随后的加密通信中主要通过**序列加密**、**分组加密**、**已验证的加密**三种加密类型加密<br>
```
序列加密
计算MAC值，MAC值包含所有记录序列号，标头、明文
然后将MAC及明文一同加密为密文

分组加密（MAC不包括填充部分）
计算MAC值，也是包括所有   
构造填充、让其满足分组大小
生成初始向量
加密，发送
上述另一种解决方法是先加密，在计算MAC

已验证的加密（使用关联数据的已验证加密）
只是用一个特殊的值nonce 加密通信中只是用一次，唯一
生成一个唯一的64位nonce
使用已验证加密算法加密明文，序列号和记录标头作为完整性校验的依据的额外信息也交个算法处理
将nonce和密文一同发送
```
- 压缩
- 扩展性
记录协议只关注数据传输和加密，将其他特性交给子协议。记录协议加密其他子协议也就加密了
##  握手协议
TLS的开始阶段必须要经历的过程，在TCP三次握手之后进行，用于协商双方的加密参数
#### 完整的握手
> 过程繁琐，握手时执行的密钥操作需要CPU处理。
对于初始的两端建立连接的过程<br>
客户端和服务器主要经历以下四个步骤
- 交换各自支持的功能，协商连接所需要的参数
客户端开始握手，将自己支持功能提交服务器<br>
**客户端发送的第一个sayhello报文结构**
```
Version 客户端支持的协议版本
Random 包含32字节的数据，随机独一无二，可用来防止重放攻击以及确认数据交换完整性
Session ID 第一次连接字段为空。后续连接中，该字段用来保存会话的唯一标识
Cipher suites 客户端支持的所有密码组件列表
Compression method 压缩的方法
Extensions 扩展的一些信息
```<br>
服务器选择连接参数<br>
**服务器发送的第一个sayhello报文结构**
`与客户端一样。但可以不用同意客户端提供的版本号，可以换成其它客户端能接收的`
- 身份验证/验证出示的证书/其它验证方法
服务器发送证书链,表明身份(一般只有服务端需要认正身份)<br>
`发送Certificate携带服务器的X506证书链`
> 只有选择证书验证身份时才发送证书
- 对用于保护会话的共享主密钥达成一致
服务端根据选择的参数发送生成主密钥的额外信息，并告知客户端自己完成过程<br>
客户端发送主密钥所需的额外信息<br>
客户端切换到加密方式，通知服务端<br>
- 验证握手信息未经第三方修改
客户端计算发送和接收到的握手消息的MAC并发送<br>
服务器切换加密方式，并计算发送和接收的握手消息的MAC并发送
![图解](http://www.garykessler.net/library/images/crypto_ssl.gif)
#### 简短握手
> 一般用来恢复会话，节省了完整握手的资源消耗。

目前采用方法为**会话票证**。服务端不用保存任何信息。所有信息都保存在客户端<br>
希望会话的客户端会将适当的会话ID放入客户端的sayhello消息提交。如果服务端同一恢复<br>
就会将相同的ID放入放入Server-sayhello。然后会用之前协商的主密钥生成新的密钥。切换为加密模式。发送Finished信息<br>
客户端接收到以后执行相同操作。这样只用往返一次。
- **密钥交换**
密钥交换是TLS中的非常重要部分，TLS的安全性取决于**主密钥**(共享密钥)<br>
密钥交换的目的就是用来计算**预主密钥**<br>
使用密钥交换的算法是在握手时的密码组件中决定的。
#### 对两端进行身份验证的握手
为了避免频繁的密码操作造成巨大开销。身份验证与密钥交换捆绑在一起。<br>
一般都是使用证书做验证，验证完会得到公钥<br>
RSA密钥交换过程
```
客户端随机生成一个随机值作为预密钥，并用服务器公钥加密发送
服务器使用私钥解析得到这个预主密钥
```
### 密钥规格变更协议
#### 重新协商
如果请求重新协商，就会发起一个新的握手。协商所有新的连接安全参数
- 客户端证书
可以在访问服务端时要求所有访问都使用该证书，无证书不允许访问<br>
也可以指定一个服务的子区域需要拥有客户端证书的才能访问
- 隐藏消息
因为在此重新协商是在已经建立加密连接的基础上进行的，这样使被动攻击者无法监听所有消息
### 应用数据协议
从TLS角度考虑，就是数据缓冲区。记录层将应用数据协议放入数据缓冲区的数据进行打包、碎片整理和加密
### 警报协议
通知机制，告知通信对端通信出现异常状况
- 警报等级
  - warning 
  - fatal
fatal等级的消息会立即终止当前连接并使会话失效，该操作由接收端处理。接收端也会发送自己的严重警告
- 关闭连接
用以有序方式关闭TLS。一旦一端决定关闭连接，就发送**close_notify**警报<br>
另一端接收到该警报丢弃所有未写出的数据，并发送自己的close_notify警报。警报达到后任何消息的到来都被忽略

### 密码操作
- 伪随机函数PRF
用于生成任意的伪随机数据，PRF使用一个secret，一个seed和一个label<br>
所有算法组件都需要指明它们的PRF,引入sedd和label则使其在不同环境中同样的输入其输出不同。<br>
密钥交换过程是生成预主密钥，可以使用PRF对该值进行处理得到48字节主密钥。<br>
连接所需的密钥，用单一PRF调用又主密钥、客户端、服务器的随机数生成<br>
- 密码组件
密码组件一般都会使用较长的名称，都由密钥交换方法、身份验证方法、密码定义及MAC或PRF算法组合而成<br>
RSA即可作为身份验证也可以作为密钥交换<br>
SHA是PRF的一种格式<br>
AES-XXX是密码
